
/*#pragma config(Sensor, dgtl5,  bitLED,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, trigger,        sensorDigitalIn)
#pragma config(Sensor, dgtl12, data,           sensorDigitalIn)//*/
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// trigger will alternate 1,0 to tell when to look for a new variable
// data will transmit binary number
// arduino sends a new bit every 100 micro seconds


////////////////////////
///		SAM PROTOCOL	///
////////////////////////

float effectiveReadRate = 0;
float bitReadRate = 0;
signed short compare = 0;

unsigned short compassRead = 0;

// 32 bits
unsigned long bits = 0;


void insertBit(bool bitToInsert)                   				// shifts bits left one, and adds new bit
{
	bits = bits << 1;                               			// shift left 1
	bits = bits | (unsigned long)bitToInsert;                   // adds new bit on the end
}

void printBits()
{
	writeDebugStream("Bits: ");
	for (int i = 31; i>=0; i--)
	{
		unsigned short temp;
		temp = bits >> i;
		temp = temp&1;
		if (i == 15)
		{
			writeDebugStream(" ");
		}
		writeDebugStream("%d",temp);
		if (i==0)
		{
			writeDebugStream("\n");
		}
	}
}


unsigned short convertBitsToInt()
{
	unsigned long temp = bits;                          // create temporary variable for mutilation
	temp = temp >> 16;                              		// cut off last 16 bits, which should all be 1s
	return (unsigned short)(temp);

}


bool checkIfValid()                                 			// checks if the number we've received is the whole thing
{
	bool valid = true;

	unsigned long temp = bits;                           // temporary variable to disfigure
	// checksum
	temp = temp&65535;
	compare = (signed short)(temp);
	compare = (compare/-9)-13;

	if (convertBitsToInt() != compare) { valid = false; }

	return valid;
}



task myReallyAwesomeSerialDriver()
{
	bool lastTrigger = false;
	bool runLED = false;
	int totalRead = 0;
	int bitTotalRead = 0;
	int justFailed = 0;
	clearTimer(T1);
	while (true)
	{
		hogCPU();                                       // get a full 32 bit number

		///////////////////////
		///     Failsafe    ///
		///////////////////////

		// bit sent every 1/10,000th of a second
		// should recieve a full number every 32/10,000ths of a second = 3 miliseconds
		// but probably won't... failsafe will be 10 miliseconds


		if (time1(T1) > 20)
		{
			USINGCOMPASS = false;
			SensorValue(bitLED) = 0;
			clearTimer(T1);
			if (justFailed == 0)
			{
				setGyro(compassDir);
				justFailed = 1;
			}
			releaseCPU();
			wait1Msec(10);
			clearTimer(T1);
		}


		if ((bool)SensorValue(trigger) != lastTrigger)  // arduino is sending the next number
		{
			lastTrigger = !lastTrigger;   // remember last trigger
			bitTotalRead++;
			bitReadRate = bitTotalRead/((1+time100(T1)/10));
			bool incomingBit = (bool)SensorValue(data); // store the bit arduino is sending

			insertBit(incomingBit);                 		// adds the new bit to bits

			if (checkIfValid())                     		// check if we've recieved the entire number
			{
				compassRead = convertBitsToInt();   			// convert our bits to int and save to compassRead

				// if (compassRead != 0) { printBits(); }		// print fails

				runLED = !runLED;
				SensorValue(bitLED) = runLED;
				totalRead++;
				effectiveReadRate = totalRead/((1+time100(T1)/10));

				//USINGCOMPASS = true;

				releaseCPU();
				wait1Msec(10);
				clearTimer(T1);                             // we've recieved a bit, so clear timer
				totalRead = 0;
				bitTotalRead = 0;
				justFailed = 0;
				//EndTimeSlice();                           // let other tasks have a turn
			}

		}
		//wait1Msec(safeFrequency);                   		// wait the right amount of time
	}
}


/*task main()
{
startTask(myReallyAwesomeSerialDriver);
}*/
