#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    mobileBaseSensor, sensorPotentiometer)
#pragma config(Sensor, in2,    powerExpanderStatus, sensorAnalog)
#pragma config(Sensor, in3,    rightWhiteLine, sensorLineFollower)
#pragma config(Sensor, in4,    leftWhiteLine,  sensorLineFollower)
#pragma config(Sensor, in5,    gyro,           sensorGyro)
#pragma config(Sensor, in6,    sweepSensor,    sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftDriveSensor, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  deploySolenoid, sensorDigitalOut)
#pragma config(Sensor, dgtl4,  bitLED,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  clawSolenoid,   sensorDigitalOut)
#pragma config(Sensor, dgtl6,  rightDriveSensor, sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  liftSensor,     sensorQuadEncoder)
#pragma config(Sensor, dgtl11, trigger,        sensorDigitalIn)
#pragma config(Sensor, dgtl12, data,           sensorDigitalIn)
#pragma config(Motor,  port1,            ,             tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           sweepMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftDrive1,    tmotorVex393HighSpeed_MC29, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port4,           mobileBaseR,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightDrive2,   tmotorVex393HighSpeed_MC29, openLoop, encoderPort, dgtl6)
#pragma config(Motor,  port6,           leftDrive2,    tmotorVex393HighSpeed_MC29, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port7,           mobileBaseL,   tmotorVex393_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port8,           rightDrive1,   tmotorVex393HighSpeed_MC29, openLoop, encoderPort, dgtl6)
#pragma config(Motor,  port9,           liftMotor,     tmotorVex393_MC29, openLoop, reversed, encoderPort, dgtl8)
#pragma config(Motor,  port10,           ,             tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

///////////////////////////////////////////////
// Competition Control and Duration Settings //
///////////////////////////////////////////////

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(45)
#pragma userControlDuration(75)

////////////////////
// INCLUDED FILES	//
////////////////////
bool driveStraight = false;							// Flag to ignore gyro when driving in auton.
int seekAngle=-1;												// Angle we want robot to turn to
float turnAccepted = 0;                  	// Motor value for which turns will terminate
int turnRate = 200;											// Turn rate for turns
int pulse1=5;														// How long to pulse for
int pulse2=15;													// How long to wait between pulses
int MINSPEED = 15;											// Minimum rotation speed for autonomous -------- was 20 (30)
int MAXTURN = 127;											// Max turn speed

#include "gyro.c"												//include gyro code

int turnRateBASE = 200;
int pulse1BASE=6;
int pulse2BASE=15;
int MINSPEEDBASE = 19;											//Minimum rotation speed for autonomous -------- was 20 (30)
int MAXTURNBASE = 127;

int turnRateNOBASE = 200;
int pulse1NOBASE=5;
int pulse2NOBASE=15;
int MINSPEEDNOBASE = 15;											//Minimum rotation speed for autonomous -------- was 20 (30)
int MAXTURNNOBASE = 127;

int turnRateDRIVE = 4;											// Turn rate for turns
int pulse1DRIVE=8;														// How long to pulse for
int pulse2DRIVE=15;													// How long to wait between pulses
int MINSPEEDDRIVE = 15;											// Minimum rotation speed for autonomous -------- was 20 (30)
int MAXTURNDRIVE = 127;											// Max turn speed

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "Magic Numbers.c"							//include magic numbers at top for ease in debugging
#include "SmartMotorLib.c"							//SmartMotors
#include "SMHacks.c"										//Fix for SmartMotors
#include "AUTONOMOUS.c"									//include autonomous arrays
// #include "PortyMcPortFace.c"         //port the code to CONVEX
//#include "myReallyAwesomeSerialDriver.c"//driver for arduino


//////////////
// #DEFINES //
//////////////

#define SLEWRATE1 8											// Slew rate for drive motors


////////////////////
// BUTTON MAPPING //
////////////////////

#define ALTKEY Btn7U
#define TOGGLECLAW Btn7D
#define LIFTUP Btn7R
#define LIFTDOWN Btn7L

#define RESETGYRO Btn8U
#define DROPPEDCONE Btn8D
#define SWEEPIN Btn8L
#define SWEEPOUT Btn8R

#define STACKCONERIGHT Btn5U
#define STACKCONELEFT Btn5D

#define BASEUPTOGGLE Btn6U
#define BASEDOWN Btn6D


/////////////////////////////////////
// GENERIC VEX OPERATING VARIABLES //
/////////////////////////////////////

// TURN VARIABLES
int turnCalibration=DRIVE;






// COMPASS
bool USINGCOMPASS = false;							// Is the compass working?
float compassDir = 0;										// Current compass direction
float compassOffset = 0;								// Offset for setting compass

// BATTERY STUFF
float batteryVoltage = 0;								// Battery voltage
float backUpBatteryVoltage = 0;					// Backup battery voltage
float minBattery = 1000000;							// To find max battery

// DRIVE
int MAXMANUALTURN = 127;								// Maximum speed user can turn at
float lastAng=0;												// Last angle we were facing
int ld = 0;															// Left drive motor speed
int rd = 0;															// Right drive motor speed
float turn=0;														// Turn rate for drive
float turnDiminish = 1;									// Current turning limit for user

// MISC
float motorSlew[10];										// Table for motor slewing
int displaymode = 1;										// What to display on LCD





///////////////////////////
// AUTON FLAGS AND SETUP //
///////////////////////////


int calibrating=0;											// Are we currently calibrating?
int startTile=1;												// Chooses autonomous mode
float *autoTab;   											// Points at autonomous table being used
int TabPoint=0;      										// Current position in table
int nextCommand=0; 											// Flag to set when ready for next command
int doneAutonomous = 0;									// Flag for if calibrated sensors												//Tile we start on
int doneSetup=0;												// Have calibrated?
float	driveTime=0;											// How long to drive for
float	driveSpeed=0;											// How fast to drive
int	turnPulse=0;												// Nudge turn speed to find angle more accurately.
float PauseTime = 0;										// Time to pause for
float breakRate = 3;        						// How hard to break
float breakTime = 0.2;      						// How long to break
float minForward = 0.2;     						// Minimum speed ratio for slow down to destination
int driveTimeOut = 0;										// How long to try before timing out
bool breakDrive = false;								// Do we want to break after driving?
int faceDirection=0;										// Direction to face in auton
bool doneDriving = false;								// Should drive terminate?
float ticksPerTile = 15950;							// 10800; 						// calculated to be 14000		18570


////////////////////////////////////
// IN THE ZONE SPECIFIC VARIABLES //
////////////////////////////////////

float sweeperSpeed=0;										// Speed the sweeper should go
float liftSpeed=0;											// Speed the lift should go
int liftSeek=-1;												// Where we want the lift to go
float stackStep = -1;										// Stack phase
int baseSeek = -1;											// Where we want the base to go
int sweeperSeek=-1;											// Where we want the sweeper to go
int matchLoadStep = -1;									// Which step of match loading we are on
float distanceDriven = 0;								// How far have we driven?
float distanceDrivenOffset = 0;					// Offset for drive distance
float distanceToDrive = 0;							// How far do we want to drive
float driveDistanceConversion = 2;			// Conversion factor
float liftPos = 0;											// Where the lift is
float sweeperPos = 0;										// Where the sweeper is
int justRemovedCone=0;									// Have we just tried to remove a cone
int conesToStack = 0;										// How many cones to stack
bool matchLoads = false;								// Are we doing matchloads?
int coneCount = 0;											// Number of cones stacked
int baseSpeed = 0;											// Speed the base lift should go
int closingClaw = 0;										// Is the claw grabbing (0 = closed)


///////////////
// PRE AUTON //
///////////////

void pre_auton()
{
	bStopTasksBetweenModes = true;
}


////////////////
// DEBUG TASK //
////////////////

task debug()
{
	//while (true)
	{
		//clearDebugStream();
		//wait10Msec(100);
	}
}


////////////////////////////////////
// CALIBRATION LOADING BAR ON LCD //
////////////////////////////////////

task loading()
{
	calibrating=1;

	clearLCDLine(1);
	displayLCDString(1,0,"0               ");

	wait1Msec(187);
	clearLCDLine(1);
	displayLCDString(1,0,"00              ");

	wait1Msec(188);
	clearLCDLine(1);
	displayLCDString(1,0,"000             ");

	wait1Msec(187);
	clearLCDLine(1);
	displayLCDString(1,0,"0000            ");

	wait1Msec(188);
	clearLCDLine(1);
	displayLCDString(1,0,"00000           ");

	wait1Msec(187);
	clearLCDLine(1);
	displayLCDString(1,0,"000000          ");

	wait1Msec(188);
	clearLCDLine(1);
	displayLCDString(1,0,"0000000         ");

	wait1Msec(187);
	clearLCDLine(1);
	displayLCDString(1,0,"00000000        ");

	wait1Msec(188);
	clearLCDLine(1);
	displayLCDString(1,0,"000000000       ");

	wait1Msec(187);
	clearLCDLine(1);
	displayLCDString(1,0,"0000000000      ");

	wait1Msec(188);
	clearLCDLine(1);
	displayLCDString(1,0,"00000000000     ");

	wait1Msec(187);
	clearLCDLine(1);
	displayLCDString(1,0,"000000000000    ");

	wait1Msec(188);
	clearLCDLine(1);
	displayLCDString(1,0,"0000000000000   ");

	wait1Msec(187);
	clearLCDLine(1);
	displayLCDString(1,0,"00000000000000  ");

	wait1Msec(188);
	clearLCDLine(1);
	displayLCDString(1,0,"000000000000000 ");

	wait1Msec(187);
	clearLCDLine(1);
	displayLCDString(1,0,"0000000000000000");

	playTone(1000,10);
	playTone(1100,10);
	playTone(1300,20);

	calibrating=0;
}


////////////////////////
// SETUP SMART MOTORS //
////////////////////////

void initSmartMotors()
{
	SmartMotorsInit();
	SmartMotorSetPowerExpanderStatusPort(powerExpanderStatus);
	//4A         5B           6C           7D
	SmartMotorsAddPowerExtender(mobileBaseR, rightDrive2, leftDrive2, mobileBaseL);

	SmartMotorSetRpmSensor( rightDrive1, rightDriveSensor, 12300);
	SmartMotorSetRpmSensor( rightDrive2, rightDriveSensor, 12300);
	SmartMotorLinkMotors(rightDrive1, rightDrive2);
	SmartMotorSetRpmSensor( leftDrive1, leftDriveSensor, -12300);
	SmartMotorSetRpmSensor( leftDrive2, leftDriveSensor, -12300);
	SmartMotorLinkMotors(leftDrive1, leftDrive2);

	//SmartMotorSetRpmSensor( liftMotor, liftSensor, 800);
	//SmartMotorSetRpmSensor( sweepMotor, sweepSensor, 6000);

	//SmartMotorSetRpmSensor( mobileBaseL, mobileBaseSensor, 1000);
	//SmartMotorLinkMotors(mobileBaseL, mobileBaseR);

	SmartMotorPtcMonitorEnable();
	SmartMotorRun();
}


//////////////////////////////////////
// CALIBRATE GYRO AND OTHER SENSORS //
//////////////////////////////////////

void InitAll()
{
	if (doneSetup==0)
	{
		startTask(loading);
		clearLCDLine(0);
		displayLCDString(0,2,"CALIBRATING!");
		for (int i =0; i<10;i++){
			motorSlew[i]=0;
		}
		if (SensorValue(mobileBaseSensor) > 2000)
		{
			startTile = 1;
		}
		else
		{
			startTile = 2;
		}
		//vexUserSetup();     //port to CONVEX

		SensorType[gyro] = sensorNone;
		SensorType[gyro] = sensorNone;				//gyrob if using two
		wait1Msec(1000);
		SensorType[gyro] = sensorGyro;
		SensorType[gyro] = sensorGyro;				//gyrob if using two
		wait1Msec(2000);
		SensorScale[gyro] = 142;
		SensorScale[gyro] = 142;							//gyrob if using two
		clearTimer(T2);
		resetGyro();
		//SensorValue(sweepSensor) = 0;
		//SensorValue(liftSensor) = 0;
		SensorValue(rightDriveSensor) = 0;
		SensorValue(leftDriveSensor) = 0;
	}
	doneSetup = 1;
}


////////////////////////
// JOYSTICK DEADZONES //
////////////////////////

int VALLEY(int speed, int min, int max)
{
	int newSpeed = speed;
	if (newSpeed<0)
	{
		if (newSpeed<-max) newSpeed = -max;
		if (newSpeed>-min) newSpeed = 0;
	}
	else
	{
		if (newSpeed>max) newSpeed = max;
		if (newSpeed<min) newSpeed = 0;
	}
	return newSpeed;
}


////////////////
// DRIVE TASK //
////////////////

task newDrive() {

	float seek,angle,ang1;

	int forward = 0;

	//float turn  =  0;

	ld = VALLEY(forward + (int)turn, 25, 127);
	rd = VALLEY(forward - (int)turn, 25, 127);

	while (true)
	{
		turnDiminish = 1;
		forward = VALLEY(-vexRT(Ch3), 20, 127);
		turn  =  (turnDiminish)*VALLEY(vexRT(Ch1), 20, 127);
		turn = turn + VALLEY(abs(forward)*turn,0,MAXMANUALTURN);
		int turnMax = 127*turnDiminish;
		turn = VALLEY(turn,0,turnMax);

		if (seekAngle>=0)		//user control angle seek override
		{
			driveTime=USER;
			driveSpeed=0;
			faceDirection=seekAngle;
			seekAngle=-1;
			turnPulse=0;
			doneDriving = false;
		}

		if (driveTime != 0)                  //auton takes over
		{
			forward = driveSpeed;

			if (driveTime == DISTANCE)
			{
				int leftDriveDist = -SensorValue(leftDriveSensor);
				int rightDriveDist = SensorValue(rightDriveSensor);     // one of these should be negative, such that forwards is positive
				int averageDist = (leftDriveDist + rightDriveDist)/2;

				forward = forward * abs(averageDist - distanceToDrive)/(1*ticksPerTile) + (forward*minForward);		// slow down when within one tile
				if (forward > 127) forward = 127;
				if (forward < -127) forward = -127;
			}

			int driveMag = driveSpeed;
			seek = faceDirection; //value in degrees to rotate to
			if (USINGCOMPASS)
			{
				angle = compassDir / 10;
			}
			else {
				angle = gyroDir / 10;
			}

			//de-rotate 'angle' so seek in range +/- 180
			ang1=seek-angle;          			//de-rotate
			if (ang1<0) {ang1=360+ang1;}    //correct de-rotation
			if (ang1>180) {ang1=ang1-360;}  //+=clockwise -=anti-clockwise

			if (driveMag<MINSPEED)
			{
				ang1=(ang1/(turnRate*2))*127;            //dividing by 90 means full speed for first 90 degrees of turn. Alter this for different turn agression
			}
			else
			{
				ang1=(ang1/(turnRate*4))*127;
			}
			if (ang1>127) {ang1=127;}       //clamp max speed
			if (ang1<-127) {ang1=-127;}     //to +/- 127

			if (ang1 > MAXTURN) ang1 = MAXTURN;
			if (ang1 < -MAXTURN) ang1 = -MAXTURN;

			if (driveMag>=MINSPEED) {					//robot moving at least MINSPEED so can find angle more accuratly
				if (ang1<0){
					if (ang1>-2){ang1=0;}else{if (ang1>-4){ang1=-4;}}
					}else {
					if (ang1<2){ang1=0;}else{if (ang1<4){ang1=4;}}
				}
			}
			else
			{
				{
					turn=ang1;
					ang1=abs(ang1);
					if (ang1<MINSPEED)
					{
						if (((lastAng>0)&&(turn<0))||((lastAng<0)&&(turn>0))) ang1=0;
						else
						{
							if (ang1>MINSPEED/5)
							{
								ang1=MINSPEED;
							}
							else
							{
								turnPulse++;
								if (turnPulse<pulse1) ang1=MINSPEED;		//2
								else
								{
									ang1=1;
									if (turnPulse>pulse2) turnPulse=0;		//4
								}
							}
						}
					}
					if (turn<0) ang1=-ang1;
				}
			}

			turn=-ang1;
			lastAng=ang1;

			// turn
			if (driveSpeed == 0)                    // must be turning
			{
				if (abs(ang1) < turnAccepted && abs(lastAng) < turnAccepted)       // if the robot is so close to the correct angle that it has stoped trying to rotate, then stop the turn
				{
					doneDriving = true;
				}
			}

			// now actually stop the drive
			if (doneDriving)
			{
				if (breakDrive)       // if we want to break...
				{
					driveSpeed = -forward/breakRate;        // drive back at some multiple of current speed
					driveTime = breakTime;           // for a specific time
					breakDrive = false;                     // don't break nextime
					doneDriving = false;
					driveTimeOut = -1;
					clearTimer(T2);
				}
				else
				{
					driveSpeed = 0;                         // stop driving
					driveTime = 0;
					nextCommand = 1;                     // ready for next command
					forward = 0;
					turn = 0;
				}
			}
		}

		if (driveStraight) {
			//turn = 0;
		}
		if (driveTime == 0)
		{
			ld = VALLEY(-vexRT[Ch2],25,127);
			rd = VALLEY(-vexRT[Ch3],25,127);
			/*
			ld = VALLEY((forward + (int)turn), 25, 127);
			rd = VALLEY((forward - (int)turn), 25, 127);//*/
		}
		else
		{
			ld = forward + (int)turn;       // no VALLEY lets us run very slowly for precise turns, etc.
			rd = forward - (int)turn;
		}

		RegMotor(leftDrive1,ld);
		RegMotor(leftDrive2,ld);
		RegMotor(rightDrive1,rd);
		RegMotor(rightDrive2,rd);

		/*
		motorSlew[leftDrive1]=ld;
		motorSlew[leftDrive2]=ld;
		motorSlew[rightDrive1]=rd;
		motorSlew[rightDrive2]=rd;
		*/
		wait1Msec(10);
	}
}


//////////////////////
// SLEW MOTORS TASK //
//////////////////////

/*void slewMotor(int index, int rate)
{
int motorValue = 0;//motor[index];
if (rate==0||rate==NULL) {rate=1;}
int difference = (motorValue - motorSlew[index])/rate;
if (difference == 0)
{

//put clever no-burnout code here, this is where all motor values are set
if (index == (int)rightDrive1 || index == (int)rightDrive2 || index == (int)leftDrive1 || index == (int)leftDrive2)
{
//RegMotor(index,motorSlew[index]);
}else{
//RegMotor(index,motorSlew[index]);
//motor[index] = motorSlew[index];
}
}
else
{

//put clever no-burnout code here, this is where all motor values are set
if (index == (int)rightDrive1 || index == (int)rightDrive2 || index == (int)leftDrive1 || index == (int)leftDrive2)
{
//RegMotor(index,motorSlew[index]);
}else{
//RegMotor(index,motorSlew[index]);
//motor[index] = motorValue-difference;
}
}
}

task slewMotors()
{
while (false)
{
int slewRate=SLEWRATE1;
if (driveTime==USER) slewRate=1;			//override for fine angle seeking control
slewMotor(rightDrive1, slewRate);
slewMotor(rightDrive2,slewRate);
slewMotor(leftDrive1,slewRate);
slewMotor(leftDrive2,slewRate);
slewMotor(sweepMotor,slewRate);
slewMotor(mobileBaseR,slewRate);
slewMotor(mobileBaseL,slewRate);
slewMotor(liftMotor,slewRate);
wait1Msec(15);
}
}*/


/////////////////////
// LCD SCREEN TASK //
/////////////////////

void screen()
{
	bLCDBacklight=true;
	if (calibrating!=1)
	{
		clearLCDLine(0);
		clearLCDLine(1);
		batteryVoltage = nImmediateBatteryLevel;
		backUpBatteryVoltage = BackupBatteryLevel;
		if (batteryVoltage<minBattery)
		{
			minBattery=batteryVoltage;
		}
		if (vexRT[RESETGYRO]==1)
		{
			displayLCDString(1,0," CALIBRATE ME!  ");
			displayLCDString(0,0,"    PLEASE!     ");
		}
		else
		{
			if (USINGCOMPASS)
			{
				displayLCDNumber(0, 0, compassDir);
			}
			else
			{
				displayLCDNumber(0, 0, gyroDir);
			}
			displayLCDNumber(0,14,startTile);
			if (displaymode%3==0)
			{
			}
			else if (displaymode%3==1)
			{

				minBattery=1000000;
			}
			else
			{
				if (nImmediateBatteryLevel<minBattery)
				{
					minBattery=nImmediateBatteryLevel;
				}
			}
		}
	}
	wait1Msec(10);
}


///////////////////////////
// MOBILE BASE LIFT TASK //
///////////////////////////

task mobileBaseStuff()																											//MOBILE BASE STUFF
{
	int mobileBaseLPos = SensorValue[mobileBaseSensor];	//READ VALUES FROM SENSORS
	int mobileBaseRPos = SensorValue[mobileBaseSensor];
	while (1)
	{
		mobileBaseLPos = SensorValue[mobileBaseSensor];	//READ VALUES FROM SENSORS
		mobileBaseRPos = SensorValue[mobileBaseSensor];

		//USER BUTTON TO 'THROW' BASE
		if (vexRT[BASEUPTOGGLE] && !vexRT[ALTKEY])
		{

			if (SensorValue(mobileBaseSensor) > baseThrowPos)
			{
				baseSeek = baseDownPos;
				}else{
				baseSeek = baseUpPos;
			}

			//baseSeek = baseThrowPos;
		}

		baseSpeed=0;
		//Base Seek Lerp
		if (baseSeek>0) baseSpeed = -(baseSeek - mobileBaseLPos)*baseSeekRate;
		if (abs(baseSeek-mobileBaseLPos)<baseCloseEnough) baseSeek=-1;

		//MANUAL BASE CONTROLS
		if (vexRT[ALTKEY])
		{
			if (vexRT[BASEUPTOGGLE])
			{
				baseSeek = -1;
				baseSpeed=-127;
			}
			if (vexRT[BASEDOWN])
			{
				baseSeek = -1;
				baseSpeed=127;
				//coneCount=0;
			}
			}else{
			if (vexRT[BASEDOWN])
			{
				liftSeek = liftReadyPos;
				sweeperSeek=1;
				closingClaw = 1;
				//coneCount=0;
			}
		}

		//now set motors
		RegMotor(mobileBaseL,baseSpeed);
		RegMotor(mobileBaseR,baseSpeed);
		/*
		motorSlew[mobileBaseR] = baseSpeed;
		motorSlew[mobileBaseL] = baseSpeed;  // + (mobileBaseRPos-mobileBaseLPos)*baseSyncParam;	//this should keep the two sides in sync*/
		wait1Msec(10);
	}
}


////////////////////////////
// LIFT AND STACKING TASK //
////////////////////////////

task doAssortedLiftActivityAndThings()		//a concise and descriptive name
{
	int justClosed = 0;
	while(420)	//for the memes
	{
		sweeperSpeed=0;
		liftSpeed=0;

		if (calibrating == 1)
		{
			if (startTile == 1)
			{
				sweeperSpeed = -30;
			}
			if (startTile==2)
			{
				sweeperSpeed = 30;
			}
		}


		liftPos = liftOffset+SensorValue(liftSensor);			//use offsets to check positions are correct everytime lift/sweeper hits max or min
		while(liftPos<0){
			liftOffset++;
			liftPos = liftOffset+SensorValue(liftSensor);
		}
		while(liftPos>liftTopPos){
			liftOffset--;
			liftPos = liftOffset+SensorValue(liftSensor);
		}
		sweeperPos = sweeperOffset+SensorValue(sweepSensor) + 50;

		/*while(sweeperPos<0){
		sweeperOffset++;
		sweeperPos = sweeperOffset+SensorValue(sweepSensor);
		}
		while(sweeperPos>maxSweeperPos){
		sweeperOffset--;
		sweeperPos = sweeperOffset+SensorValue(sweepSensor);
		}*/

		if (vexRT[ALTKEY])			//stop all autonomous movements
		{
			sweeperSeek=-1;
			liftSeek=-1;
			baseSeek=-1;
			stackStep=-1;
			matchLoads = false;
			matchLoadStep = -1;
			driveTime = 0;
			nextCommand = true;
			//driveStraight = false;
		}

		if (vexRT[TOGGLECLAW]  && !vexRT[ALTKEY])
		{
			if (justClosed == 0)
			{
				if (closingClaw == 0)
				{
					closingClaw = 1;
				}
				else
				{
					closingClaw = 0;
				}
				justClosed = 1;
			}
		}
		else
		{
			justClosed = 0;
		}

		//USER COMMAND TO STACK
		if (vexRT[STACKCONERIGHT])
		{
			stackStep=1;
			stackSide = RIGHT;
			clearTimer(T3);
		}
		if (vexRT[STACKCONELEFT])
		{
			stackStep=1;
			stackSide = LEFT;
			clearTimer(T3);
		}

		//USER COMMAND TO TELL ROBOT IT DROPPED A CONE
		if (vexRT[DROPPEDCONE])
		{
			if (justRemovedCone==0)
			{
				justRemovedCone=1;
				if (!vexRT[ALTKEY])
				{
					coneCount--;
					if (coneCount<0){coneCount=0;}
				}
				else
				{
					driveStraight=!driveStraight;
				}
			}
		}
		if (!vexRT[DROPPEDCONE])
		{
			justRemovedCone=0;
		}


		///////////////
		// AUTOSTACK //
		///////////////

		stackSide = LEFT;

		if (stackSide == LEFT) sweeperHomePos = sweeperHomePosLeft;
		if (stackSide == RIGHT) sweeperHomePos = sweeperHomePosRight;

		if (stackStep == 1)
		{
			liftSeek = liftReadyPos;
			//sweeperSpeed = stackSide*sweeperSwingSpeed;
			sweeperSeek = 1;
			if ((sweeperPos*stackSide > (sweeperHomePos+50)*stackSide && time1(T3)>50) || time1(T3)>250)
			{
				liftSeek = -1;
				clearTimer(T3);
				stackStep = 3;
			}
		}


		/*if (stackStep==1)		//ready to grab cone
		{
		//sweeperSeek = sweeperHomePos;		//make sure everything is in the correct starting position
		//if (!vexRT[STACKCONELEFT] && !vexRT[STACKCONERIGHT])
		{
		sweeperSpeed = -stackSide*sweeperSwingSpeed;
		liftSeek = liftReadyPos;
		// closingClaw = 1;

		if (sweeperPos*stackSide<sweeperStackPos*stackSide)
		{
		stackStep = 888;
		}

		if ((sweeperPos*stackSide > (sweeperHomePos+50)*stackSide && time1(T3)>50) || time1(T3)>1000)
		{
		liftSeek = -1;
		clearTimer(T3);
		stackStep=2;
		}
		}
		}

		if (stackStep == 888)
		{
		liftSeek = liftTopPos;
		sweeperSeek = -1;
		sweeperSpeed = stackSide*80;
		if (liftPos>liftLowPos)
		{
		stackStep = 889;
		}
		}

		if (stackStep == 889)
		{
		sweeperSpeed = -stackSide*127;
		if (abs(sweeperPos-sweeperHomePos)<50)
		{
		stackStep = 1;
		}
		}
		if (stackStep == 2)
		{
		liftSpeed = -127;
		sweeperSeek = sweeperHomePos;
		if ((liftPos < liftSeek+100 && time1(T3)>50) || time1(T3) > 1500)
		{
		liftSeek = -1;
		clearTimer(T3);
		stackStep = 3;
		coneCount++;								//count cone before lift comes down, we don't need a seperate button for adding cone, just start autostack, and cancel it

		}
		}*/

		if (stackStep == 3)
		{
			closingClaw = 0;
			if (time1(T3)>100)
			{
				clearTimer(T3);
				liftSeek = -1;
				stackStep = 4;
				coneCount++;								//count cone before lift comes down, we don't need a seperate button for adding cone, just start autostack, and cancel it

			}
		}
		if (stackStep == 4)
		{
			liftSpeed = 127;
			sweeperSeek = 1;
			if (liftPos > lowestConeHeight+((coneCount-1)*coneHeight) || time1(T3)>3000 || liftPos >= liftTopPos)
			{
				clearTimer(T3);
				liftSeek = -1;
				sweeperSeek = -1;
				stackStep = 5;
			}
		}
		if (stackStep == 5)
		{
			liftSeek = lowestConeHeight+((coneCount-1)*coneHeight);
			sweeperSpeed = -sweeperStackSpeed*stackSide;
			if (sweeperPos>sweeperStackPos || time1(T3)>1000)
			{
				clearTimer(T3);
				if (coneCount!=4) liftSeek = -1;
				stackStep = 7;		// 6
			}
		}
		/*if (stackStep == 6)
		{
		sweeperSpeed = -sweeperStackSpeed*stackSide/2;
		if (sweeperPos*stackSide>sweeperStackPos*stackSide || time1(T3)>1000)
		{
		clearTimer(T3);
		if (coneCount!=4) liftSeek = -1;
		stackStep = 999;
		}
		}
		if (stackStep == 999)
		{
		sweeperSeek = sweeperStackPos;
		if (time1(T3)>sweeperHoldTime1)
		{
		clearTimer(T3);
		if (coneCount!=4) liftSeek = -1;
		sweeperSeek = -1;
		stackStep = 7;
		}
		}*/
		if (stackStep == 7)
		{
			sweeperSpeed = sweeperStackSpeed/3;
			if (time1(T3)>sweeperHoldTime2)
			{
				clearTimer(T3);
				liftSeek = -1;
				stackStep = 8;
			}
		}
		if (stackStep == 8)
		{
			sweeperSpeed = -sweeperStackSpeed*stackSide;
			liftSeek = lowestConeHeight+((coneCount-2)*coneHeight);
			if (time1(T3)>200)
			{
				clearTimer(T3);
				liftSeek = -1;
				stackStep = 9;
			}
		}
		if (stackStep == 9)
		{
			closingClaw = 1;
			if (time1(T3)>100)
			{
				clearTimer(T3);
				liftSeek = -1;
				stackStep = 210;
				if (stackSide == LEFT) sweeperHomePos = sweeperHomePosLeft;
				if (stackSide == RIGHT) sweeperHomePos = sweeperHomePosRight;
			}
		}
		if (stackStep == 210)
		{
			if (time1(T3)>250)
			{
				clearTimer(T3);
				liftSeek = -1;
				stackStep = 10;
			}
		}
		if (stackStep == 10)
		{
			liftSeek = lowestConeHeight+((coneCount)*coneHeight);
			sweeperSeek = 1;
			if (time1(T3)>500)
			{
				clearTimer(T3);
				liftSeek = -1;
				stackStep = 11;
			}
		}
		if (stackStep==11)
		{
			sweeperSeek = 1;
			//	sweeperSpeed = 127*stackSide;		//make sure everything is in the correct starting position
			liftSeek = liftReadyPos;
			if ((sweeperPos*stackSide>sweeperSeek*stackSide && time1(T3)>100) || time1(T3)>500)
			{
				liftSeek = liftReadyPos;
				//sweeperSeek = -1;
				clearTimer(T3);
				stackStep=-1;
			}
		}

		///Sweeper Seek Lerp
		if (sweeperSeek>=0)
		{
			sweeperSpeed = -(sweeperSeek - sweeperPos)/sweeperSeekRate;
			if (sweeperSpeed>sweeperMaxSwing*3/2) sweeperSpeed = sweeperMaxSwing*3/2;
			if (sweeperSpeed<-sweeperMaxSwing) sweeperSpeed = -sweeperMaxSwing;
			if (abs(sweeperSeek-sweeperPos)<sweeperCloseEnough && sweeperSeek!=-1) sweeperSpeed = 0;
		}					//this line stops seeking when it gets close


		///Lift Seek Lerp
		if (liftSeek>=0)
		{
			if (liftSeek>liftPos) liftSpeed = (liftSeek - liftPos)*liftSeekRateUp;
			if (liftSeek<liftPos) liftSpeed = (liftSeek - liftPos)*liftSeekRateDown;
			if (abs(liftSeek-liftPos)<liftCloseEnough) liftSpeed=0;										//this line stops seeking when it gets close
		}

		//MANUAL SWEEPER CONTROLS
		if (vexRT[SWEEPIN])
		{
			sweeperSeek = -1;
			sweeperSpeed=-sweeperMaxSwing;
		}
		if (vexRT[SWEEPOUT])
		{
			sweeperSeek = -1;
			sweeperSpeed=127;
		}

		//MANUAL LIFT CONTROLS
		if (vexRT[LIFTUP])
		{
			liftSeek = -1;
			liftSpeed=127;
		}
		if (vexRT[LIFTDOWN])
		{
			liftSeek = -1;
			liftSpeed=-127;
		}

		//Lift Sync Code && run motors

		RegMotor(sweepMotor,sweeperSpeed);
		RegMotor(liftMotor,liftSpeed);

		SensorValue(clawSolenoid) = closingClaw;

		//motor[liftMotor] = liftSpeed;
		//motor[sweepMotor] = sweeperSpeed;
		/*
		motorSlew[sweepMotor] = sweeperSpeed;
		motorSlew[liftMotor] = liftSpeed;*/
		wait1Msec(10);
	}
}


/////////////////
// DEPLOY TASK //
/////////////////

task deploy()
{
	SensorValue(deploySolenoid) = 1;
	wait1Msec(250);
	SensorValue(deploySolenoid) = 0;
}


//////////////////////////
// TASKS TO RUN COMPASS //
//////////////////////////

void setCompass(int dir)
{
	//compassOffset = dir - compassRead;
	//compassDir = compassRead + dir - compassRead;
}

task doCompass()
{
	while (true)
	{

		if (compassDir < 0) compassOffset+= 3600;
		if (compassDir >= 3600) compassOffset-= 3600;

		//compassDir = compassRead + compassOffset;

		wait1Msec(10);
	}
}


/////////////////////////
//// AUTONOMOUS TASK ////
/////////////////////////

task autonomous()
//task usercontrol()
{
	//int followingLine=0;
	//Declare variables
	InitAll();
	initSmartMotors();
	doneAutonomous=1;
	driveTime=0;
	clearTimer(T1);
	TabPoint=0;
	nextCommand=1;
	int PauseTimeOut = 0;
	driveStraight = false;

	////////////////////
	//    TESTING     //
	//  startTile=1;  //
	////////////////////

	if (startTile==1) {autoTab=&regAuton;}		//autonomous commands to reference
	if (startTile==2) {autoTab=&spicyAuton;}		//autonomous commands to reference



	startTask(readGyro);
	//startTask(slewMotors);
	startTask(newDrive);
	startTask(doAssortedLiftActivityAndThings);
	startTask(mobileBaseStuff);
	//startTask(myReallyAwesomeSerialDriver);
	//startTask(doCompass);
	startTask(deploy);
	writeDebugStreamLine("Auto Deploy");
	startTask(trackMotorStrain);

	//set truedir from table
	setGyro((autoTab[0])*10);
	setCompass((autoTab[0])*10);
	autoTab+=1;
	clearTimer(T4);

	if (true)
	{
		while (true)
		{
			screen();
			driveSlewRate = 256;

			////////////////////////////////////////
			//	process autonomous command table	//
			////////////////////////////////////////

			if (nextCommand) 											//ready for new command. Some commands below will set nextCommand immediately
				//whereas others (e.g. PAUSE) wait for timers to finish before asking for
			//the next command.
			{
				writeDebugStreamLine("\tTime Is: %f",time1(T1));
				nextCommand=0;											//command processing
				switch(autoTab[TabPoint]){					//read command from table
				case DRIVE:
					// turnCalibration = DRIVE;
				case TURN:													//process DRIVE command
					writeDebugStream("Drive Command, ");
					// DRIVE,SPEED,DIRECTION,BREAKING,TIME
					// DRIVE,SPEED,DIRECTION,BREAKING,WHITE,TIMEOUT
					// DRIVE,SPEED,DIRECTION,BREAKING,DISTANCE,DIST,TIMEOUT

					if (turnCalibration == DRIVE)
					{
						turnRate = turnRateDRIVE;
						pulse1=pulse1DRIVE;
						pulse2=pulse2DRIVE;
						MINSPEED = MINSPEEDDRIVE;
						MAXTURN = MAXTURNDRIVE;
					}
					else if (turnCalibration == GOTBASE)
					{
						turnRate = turnRateBASE;
						pulse1=pulse1BASE;
						pulse2=pulse2BASE;
						MINSPEED = MINSPEEDBASE;
						MAXTURN = MAXTURNBASE;						}
					else if (turnCalibration == NOBASE)
					{
						turnRate = turnRateNOBASE;
						pulse1=pulse1NOBASE;
						pulse2=pulse2NOBASE;
						MINSPEED = MINSPEEDNOBASE;
						MAXTURN = MAXTURNNOBASE;						}

					TabPoint++;
					driveSpeed = -autoTab[TabPoint];
					TabPoint++;
					faceDirection = autoTab[TabPoint];
					TabPoint++;
					//breakDrive = (bool)(autoTab[TabPoint]);
					//TabPoint++;
					driveTime = autoTab[TabPoint];
					TabPoint++;

					if (driveTime < 0)
					{
						if (driveTime <= LEFTWHITE && driveTime >= BBLACK)
						{
							driveTimeOut = autoTab[TabPoint]*1000;
							TabPoint++;
						}
						if (driveTime == DISTANCE)
						{
							int leftDriveDist = -SensorValue(leftDriveSensor);
							int rightDriveDist = -SensorValue(rightDriveSensor);     // one of these should be negative, such that forwards is positive
							int averageDist = (leftDriveDist + rightDriveDist)/2;
							float distance = autoTab[TabPoint];
							distanceToDrive = averageDist + (distance*ticksPerTile*(-driveSpeed/abs(driveSpeed)));     // distance should be added if going forwards, subtracted if backwards
							TabPoint++;
							driveTimeOut = autoTab[TabPoint]*1000;
							TabPoint++;
						}
					}

					doneDriving = false;
					writeDebugStreamLine("%f",driveTime);
					clearTimer(T2);
					break;
				case PAUSE:													//process PAUSE command.
					writeDebugStreamLine("Pause Command");
					//PAUSE, TIME,
					//PAUSE, CONDITION, TIMOUT
					TabPoint++;
					PauseTime=autoTab[TabPoint];		//read 'pause length' from table
					TabPoint++; //ready for next command in table
					if (PauseTime<0)
					{
						PauseTimeOut = autoTab[TabPoint];
						TabPoint++;
						}else{
						PauseTimeOut=-1;
					}
					clearTimer(T2);										//reset timer so it can be used to measure length of pause
					break;
				case STACK:													//process STACK command.
					writeDebugStreamLine("Stack Command");
					conesToStack = autoTab[TabPoint+1];//tell how many cones to stack
					TabPoint+=2;											//ready for next command in table
					if (conesToStack>0)
					{
						stackStep=1;											//start the stacking
					}
					nextCommand=1;
					clearTimer(T3);
					break;
				case PRELOAD:													//process PRELOAD command.
					writeDebugStreamLine("Preload Command");
					coneCount = 1;
					conesToStack = 1;									//tell how many cones to stack
					TabPoint+=1;											//ready for next command in table
					stackStep=8;											//start the stacking at the right step (4)
					nextCommand=1;
					clearTimer(T3);
					break;
				case LIFTPOS:													//process LIFTPOS command.
					writeDebugStreamLine("Liftpos Command");
					liftSeek=autoTab[TabPoint+1];				//seek with lift
					TabPoint+=2;												//ready for next command in table
					nextCommand=1;
					break;
				case SWEEPPOS:													//process SWEEPPOS command.
					writeDebugStreamLine("Sweeppos Command");
					sweeperSeek=autoTab[TabPoint+1];		//seek with lift
					TabPoint+=2;												//ready for next command in table
					nextCommand=1;
					break;
				case BASEPOS:													//process BASEPOS command.
					writeDebugStreamLine("Basepos Command");
					baseSeek=autoTab[TabPoint+1];		//seek with lift
					TabPoint+=2;												//ready for next command in table
					nextCommand=1;
					break;
				case SETGYRO:												//process SETGYRO command.
					writeDebugStreamLine("Setgyro Command");
					driveStraight=false;
					setGyro((autoTab[TabPoint+1])*10);
					//					truedir=autoTab[TabPoint+1];			//sets gyro direction based on parameter read from command table.
					//this is used to recalibrate gyro when robot direction is known.
					TabPoint+=2;											//ready for next command in table
					nextCommand=1;										//immediately ask to process next command
					break;
				case DRIVESTRAIGHT:
					writeDebugStreamLine("Drivestraight Command");
					turnCalibration = DRIVE;
					driveStraight = true;					//tell newDrive to ignore 'turn' should stop robot veering off course
					TabPoint+=1;											//move pointer
					nextCommand=1;										//ready for next command
					break;
				case STOPDRIVESTRAIGHT:
					writeDebugStreamLine("Stopdrivestraight Command");
					driveStraight = false;					//tell newDrive to use 'turn' robot may start veering off course
					TabPoint+=1;											//move pointer
					nextCommand=1;										//ready for next command
					break;
				case CONENUMBER:
					writeDebugStreamLine("Conenumber Command");
					coneCount = autoTab[TabPoint+1];	//tell robot how many cones it has
					TabPoint+=2;
					nextCommand = 1;
					break;
				case GOTBASE:
					writeDebugStreamLine("Gotbase Command");
					turnCalibration = GOTBASE;
					nextCommand = 1;
					TabPoint++;
					break;
				case NOBASE:
					writeDebugStreamLine("Nobase Command");
					turnCalibration = NOBASE;
					nextCommand = 1;
					TabPoint++;
					break;
				case SLOW:
					writeDebugStreamLine("Slow Command");
					MINSPEED = 0;
					TabPoint++;
					nextCommand = 1;
					break;
				case RESETDRIVE:
					writeDebugStreamLine("Resetdrive Command");
					SensorValue(rightDriveSensor) = 0;
					SensorValue(leftDriveSensor) = 0;
					TabPoint++;
					nextCommand = 1;
					break;
				case SETCOMPASS:
					writeDebugStreamLine("Setcompass Command");
					TabPoint++;
					setCompass(autoTab[TabPoint]);
					TabPoint++;
					nextCommand = 1;
					break;
				case CONESIDE:
					writeDebugStreamLine("Coneside Command");
					TabPoint++;
					stackSide = autoTab[TabPoint];
					TabPoint++;
					nextCommand = 1;
					break;
				case END:
					writeDebugStreamLine("End Command %f",time1(T1));
					//Do nothing
					break;
				}
			}

			wait1Msec(5);

			if (PauseTime>0)
			{
				if (time1(T2)>=PauseTime*1000)
				{
					PauseTime=0;
					nextCommand=1;
				}
			}
			else 		// CONDITIONAL PAUSE
			{
				if (PauseTime<0)
				{
					if (time1(T2)>=PauseTimeOut*1000 && PauseTimeOut>=0)
					{
						PauseTime=0;
						nextCommand=1;
					}
					if (PauseTime==BASEISDOWN)
					{
						if (SensorValue(mobileBaseSensor)<baseDownPos+baseCloseEnough)
						{
							PauseTime=0;
							nextCommand=1;
						}
					}
					if (PauseTime==BASEISHALFDOWN)
					{
						if (SensorValue(mobileBaseSensor)<baseThrowPos)
						{
							PauseTime=0;
							nextCommand=1;
						}
					}
					if (PauseTime==BASEISUP)
					{
						if (SensorValue(mobileBaseSensor)>baseUpPos-baseCloseEnough)
						{
							PauseTime=0;
							nextCommand=1;
						}
					}
					if (PauseTime==DONESTACK)
					{
						if (stackStep==-1 && conesToStack<=1)
						{
							PauseTime=0;
							nextCommand=1;
						}
					}
					if (PauseTime==CONEUP)
					{
						if (((stackStep>=5)|| stackStep==-1) && conesToStack<=1)
						{
							PauseTime=0;
							nextCommand=1;
						}
					}
				}
			}


			distanceDriven = ((SensorValue(rightDriveSensor)+SensorValue(leftDriveSensor))/driveDistanceConversion)-distanceDrivenOffset;


			if (driveTime!=0)
			{
				if (driveTime == DISTANCE)
				{

					int leftDriveDist = -SensorValue(leftDriveSensor);
					int rightDriveDist = -SensorValue(rightDriveSensor);     // one of these should be negative, such that forwards is positive
					int averageDist = (leftDriveDist + rightDriveDist)/2;

					if (driveSpeed < 0)
					{
						if (averageDist > distanceToDrive || time1(T2)>=driveTimeOut)          // forwards
						{
							doneDriving = true;
						}
					}
					else
					{
						if (averageDist < distanceToDrive || time1(T2)>=driveTimeOut)          // backwards
						{
							doneDriving = true;
						}
					}
				}
				if (driveTime == LEFTWHITE)
				{
					if (SensorValue(leftWhiteLine) < leftWhiteLineAccepted || time1(T2)>=driveTimeOut)
					{
						doneDriving = true;
					}
				}
				if (driveTime == LEFTBLACK)
				{
					if (SensorValue(leftWhiteLine) > leftWhiteLineAccepted || time1(T2)>=driveTimeOut)
					{
						doneDriving = true;
					}
				}
				if (driveTime == RIGHTWHITE)
				{
					if (SensorValue(rightWhiteLine) < rightWhiteLineAccepted || time1(T2)>=driveTimeOut)
					{
						doneDriving = true;
					}
				}
				if (driveTime == RIGHTBLACK)
				{
					if (SensorValue(rightWhiteLine) > rightWhiteLineAccepted || time1(T2)>=driveTimeOut)
					{
						doneDriving = true;
					}
				}
				if (driveTime == EWHITE)
				{
					if (SensorValue(rightWhiteLine) < rightWhiteLineAccepted || SensorValue(leftWhiteLine) < leftWhiteLineAccepted || time1(T2)>=driveTimeOut)
					{
						doneDriving = true;
					}
				}
				if (driveTime == EBLACK)
				{
					if (SensorValue(rightWhiteLine) > rightWhiteLineAccepted || SensorValue(leftWhiteLine) > leftWhiteLineAccepted || time1(T2)>=driveTimeOut)
					{
						doneDriving = true;
					}
				}
				if (driveTime == BWHITE)
				{
					if ((SensorValue(rightWhiteLine) < rightWhiteLineAccepted && SensorValue(leftWhiteLine) < leftWhiteLineAccepted) || time1(T2)>=driveTimeOut)
					{
						doneDriving = true;
					}
				}
				if (driveTime == BBLACK)
				{
					if ((SensorValue(rightWhiteLine) > rightWhiteLineAccepted && SensorValue(leftWhiteLine) > leftWhiteLineAccepted) || time1(T2)>=driveTimeOut)
					{
						doneDriving = true;
					}
				}


				if (driveTime>0)
				{
					if (time1(T2)>=driveTime*1000)
					{
						doneDriving = true;
					}
				}
			}
		}
	}
}


///////////////////////////
//// USER CONTROL TASK ////
///////////////////////////

task usercontrol()
//task autonomous()
{
	InitAll();
	initSmartMotors();
	if (doneAutonomous==0)
	{
		//playSoundFile("windows.wav");
	}
	PauseTime=0;
	//driveTime=0;
	int lastPressed=0;
	clearTimer(T1);

	startTask(debug);
	//startTask(slewMotors);
	startTask(readGyro);
	startTask(newDrive);
	startTask(doAssortedLiftActivityAndThings);
	startTask(mobileBaseStuff);
	//startTask(myReallyAwesomeSerialDriver);
	//startTask(doCompass);
	startTask(trackMotorStrain);

	clearTimer(T4);

	driveTime = 0;
	driveStraight = true;
	driveSlewRate = 50;
	while(1 == 1)
	{

		if (vexRT[TOGGLECLAW] == 1 && vexRT[ALTKEY])
		{
			SensorValue[deploySolenoid] = 1;
		}
		else
		{
			SensorValue[deploySolenoid] = 0;
		}


		/*while (!doneCompassInit)
		{
		if (compassRead!=0)
		{
		setCompass(0);
		doneCompassInit=true;
		}
		wait1Msec(5);
		}*/



		screen();
		PauseTime=0;

		///////////////////////
		// Initial setup mode
		///////////////////////

		if (doneAutonomous == 0)
		{
			{
				if (nLCDButtons==1 && nLCDButtons!=lastPressed)
				{
					playTone(1000,10);
					if (startTile<autonNo)
					{
						startTile++;
						}else{
						startTile=1;
					}
				}

				if (nLCDButtons==2 && nLCDButtons!=lastPressed)
				{
					displaymode++;
					playTone(1000,10);
				}
				if (nLCDButtons==4 && lastPressed!=nLCDButtons && vexRT[RESETGYRO]==1)
				{
					playTone(1000,10);
					doneSetup=0;
					InitAll();
				}

				lastPressed=nLCDButtons;
			}
		}


		if (vexRT[RESETGYRO]==1)		//reset gyro
		{
			resetGyro();
			setCompass(0);
		}

		if (vexRT[RESETGYRO] && vexRT[ALTKEY])	//no screen, so calibrate on a button combo
		{
			playTone(1000,10);
			doneSetup=0;
			InitAll();
			initSmartMotors();
		}
		wait1Msec(10);
	}
}
